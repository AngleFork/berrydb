// Copyright 2017 The BerryDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "./pool_impl.h"

#include "berrydb/options.h"
#include "berrydb/platform.h"
#include "berrydb/vfs.h"
#include "./store_impl.h"

namespace berrydb {

static_assert(std::is_standard_layout<PoolImpl>::value,
    "PoolImpl must be a standard layout type so its public API can be "
    "exposed cheaply");

PoolImpl* PoolImpl::Create(const PoolOptions& options) {
  void* heap_block = Allocate(sizeof(PoolImpl));
  PoolImpl* pool = new (heap_block) PoolImpl(options);
  DCHECK_EQ(heap_block, static_cast<void*>(pool));
  return pool;
}

PoolImpl::PoolImpl(const PoolOptions& options)
    : api_(), page_pool_(options.page_shift, options.page_pool_size),
      vfs_((options.vfs == nullptr) ? DefaultVfs() : options.vfs) {
}

PoolImpl::~PoolImpl() { }

void PoolImpl::Release() {
  // Replace the entire store list so StoreClosed() doesn't invalidate our
  // iterator.
  StoreSet close_queue;
  close_queue.swap(stores_);
  for (StoreImpl* store : close_queue)
    store->Close();

  // The existence of pinned pages implies that some transactions are still
  // running. This should not be the case, as all the stores should have been
  // closed.
  DCHECK_EQ(0, page_pool_.pinned_pages());

  // The difference between allocated pages and unused pages is pages in the MRU
  // queue. All the stores should have been closed, so the MRU should be empty.
  DCHECK_EQ(page_pool_.allocated_pages(), page_pool_.unused_pages());

  this->~PoolImpl();
  void* heap_block = static_cast<void*>(this);
  Deallocate(heap_block, sizeof(PoolImpl));
}

Status PoolImpl::OpenStore(
    const std::string& path, const StoreOptions& options,
    StoreImpl** result) {
  BlockAccessFile* data_file;
  Status status = vfs_->OpenForBlockAccess(
      path, page_pool_.page_shift(), options.create_if_missing,
      options.error_if_exists, &data_file);
  if (status != Status::kSuccess)
    return status;

  // TODO(pwnall): Lock the data file to prevent against accidental concurrent
  //               store opens.

  StoreImpl* store = StoreImpl::Create(data_file, &page_pool_, options);

  stores_.insert(store);
  *result = store;
  return Status::kSuccess;
}

}  // namespace berrydb
